// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chat.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (uuid, thread_uuid, role, content, emotion)
VALUES ($1, $2, $3, $4, $5)
RETURNING uuid, thread_uuid, role, content, emotion, created_at
`

type CreateChatMessageParams struct {
	Uuid       pgtype.UUID
	ThreadUuid pgtype.UUID
	Role       string
	Content    string
	Emotion    pgtype.Text
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.Uuid,
		arg.ThreadUuid,
		arg.Role,
		arg.Content,
		arg.Emotion,
	)
	var i ChatMessage
	err := row.Scan(
		&i.Uuid,
		&i.ThreadUuid,
		&i.Role,
		&i.Content,
		&i.Emotion,
		&i.CreatedAt,
	)
	return i, err
}

const createChatThread = `-- name: CreateChatThread :one
INSERT INTO chat_threads (uuid, visitor_uuid)
VALUES ($1, $2)
RETURNING uuid, created_at, visitor_uuid
`

type CreateChatThreadParams struct {
	Uuid        pgtype.UUID
	VisitorUuid pgtype.UUID
}

func (q *Queries) CreateChatThread(ctx context.Context, arg CreateChatThreadParams) (ChatThread, error) {
	row := q.db.QueryRow(ctx, createChatThread, arg.Uuid, arg.VisitorUuid)
	var i ChatThread
	err := row.Scan(&i.Uuid, &i.CreatedAt, &i.VisitorUuid)
	return i, err
}

const getChatMessagesByThread = `-- name: GetChatMessagesByThread :many
SELECT uuid, thread_uuid, role, content, emotion, created_at FROM chat_messages
WHERE thread_uuid = $1
ORDER BY created_at ASC
`

func (q *Queries) GetChatMessagesByThread(ctx context.Context, threadUuid pgtype.UUID) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getChatMessagesByThread, threadUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.Uuid,
			&i.ThreadUuid,
			&i.Role,
			&i.Content,
			&i.Emotion,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMessagesByThreadLimit = `-- name: GetChatMessagesByThreadLimit :many
SELECT uuid, thread_uuid, role, content, emotion, created_at FROM chat_messages
WHERE thread_uuid = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetChatMessagesByThreadLimitParams struct {
	ThreadUuid pgtype.UUID
	Limit      int32
}

func (q *Queries) GetChatMessagesByThreadLimit(ctx context.Context, arg GetChatMessagesByThreadLimitParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getChatMessagesByThreadLimit, arg.ThreadUuid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.Uuid,
			&i.ThreadUuid,
			&i.Role,
			&i.Content,
			&i.Emotion,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatThread = `-- name: GetChatThread :one
SELECT uuid, created_at, visitor_uuid FROM chat_threads
WHERE uuid = $1
`

func (q *Queries) GetChatThread(ctx context.Context, uuid pgtype.UUID) (ChatThread, error) {
	row := q.db.QueryRow(ctx, getChatThread, uuid)
	var i ChatThread
	err := row.Scan(&i.Uuid, &i.CreatedAt, &i.VisitorUuid)
	return i, err
}
